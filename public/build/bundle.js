var app=function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function r(e){e.forEach(t)}function a(e){return"function"==typeof e}function o(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function i(e,t,n){e.insertBefore(t,n||null)}function s(e){e.parentNode.removeChild(e)}function l(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}let u;function m(e){u=e}function c(e){(function(){if(!u)throw new Error("Function called outside component initialization");return u})().$$.on_mount.push(e)}const h=[],f=[],d=[],x=[],p=Promise.resolve();let y=!1;function g(e){d.push(e)}function v(e){x.push(e)}let b=!1;const $=new Set;function w(){if(!b){b=!0;do{for(let e=0;e<h.length;e+=1){const t=h[e];m(t),M(t.$$)}for(h.length=0;f.length;)f.pop()();for(let e=0;e<d.length;e+=1){const t=d[e];$.has(t)||($.add(t),t())}d.length=0}while(h.length);for(;x.length;)x.pop()();y=!1,b=!1,$.clear()}}function M(e){if(null!==e.fragment){e.update(),r(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(g)}}const T=new Set;let k;function C(e,t){e&&e.i&&(T.delete(e),e.i(t))}function S(e,t,n){const r=e.$$.props[t];void 0!==r&&(e.$$.bound[r]=n,n(e.$$.ctx[r]))}function E(e,n,o){const{fragment:i,on_mount:s,on_destroy:l,after_update:u}=e.$$;i&&i.m(n,o),g(()=>{const n=s.map(t).filter(a);l?l.push(...n):r(n),e.$$.on_mount=[]}),u.forEach(g)}function B(e,t){const n=e.$$;null!==n.fragment&&(r(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function P(e,t){-1===e.$$.dirty[0]&&(h.push(e),y||(y=!0,p.then(w)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function _(t,a,o,i,l,c,h=[-1]){const f=u;m(t);const d=a.props||{},x=t.$$={fragment:null,ctx:null,props:c,update:e,not_equal:l,bound:n(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(f?f.$$.context:[]),callbacks:n(),dirty:h};let p=!1;if(x.ctx=o?o(t,d,(e,n,...r)=>{const a=r.length?r[0]:n;return x.ctx&&l(x.ctx[e],x.ctx[e]=a)&&(x.bound[e]&&x.bound[e](a),p&&P(t,e)),n}):[],x.update(),p=!0,r(x.before_update),x.fragment=!!i&&i(x.ctx),a.target){if(a.hydrate){const e=function(e){return Array.from(e.childNodes)}(a.target);x.fragment&&x.fragment.l(e),e.forEach(s)}else x.fragment&&x.fragment.c();a.intro&&C(t.$$.fragment),E(t,a.target,a.anchor),w()}m(f)}"function"==typeof HTMLElement&&(k=class extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"})}connectedCallback(){for(const e in this.$$.slotted)this.appendChild(this.$$.slotted[e])}attributeChangedCallback(e,t,n){this[e]=n}$destroy(){B(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(){}});const z=[];const O={moveTo:e=>2===e.length?"moveTo must have 2 parameters":null,lineTo:e=>2===e.length?"lineTo must have 2 parameters":null,bezierCurveTo:e=>6===e.length?"bezierCurveTo must have 6 parameters":null,quadraticCurveTo:e=>4===e.length?"quadraticCurveTo must have 4 parameters":null,arc:e=>5===e.length||6===e.length?"arc must have 5 or 6 parameters":null,arcTo:e=>5===e.length?"arcTo must have 5 parameters":null,ellipse:e=>7===e.length||8===e.length?"ellipse must have 7 or 8 parameters":null,rect:e=>4===e.length?"rect must have 4 parameters":null,closePath:e=>0===e.length?"closePath must have 0 parameters":null},j={moveTo:(e,t)=>({xmin:e,ymin:t,xmax:e,ymax:t}),lineTo:(e,t)=>({xmin:e,ymin:t,xmax:e,ymax:t}),bezierCurveTo:(e,t,n,r,a,o)=>({xmin:Math.min(e,n,a),ymin:Math.min(t,r,o),xmax:Math.max(e,n,a),ymax:Math.max(t,r,o)}),quadraticCurveTo:(e,t,n,r)=>({xmin:Math.min(e,n),ymin:Math.min(t,r),xmax:Math.max(e,n),ymax:Math.max(t,r)}),arc:(e,t,n)=>({xmin:e-n,ymin:t-n,xmax:e+n,ymax:t+n}),arcTo:(e,t,n,r)=>({xmin:Math.min(e,n),ymin:Math.min(t,r),xmax:Math.max(e,n),ymax:Math.max(t,r)}),ellipse:(e,t,n,r)=>({xmin:Math.min(e-n,e-r),ymin:Math.min(t-r,t-r),xmax:Math.max(e+n,e+n),ymax:Math.max(t+r,t+r)}),rect:(e,t,n,r)=>({xmin:e,ymin:t,xmax:e+n,ymax:t+r})};function L(e,t,n){return e*n[0]+t*n[2]+n[4]}function A(e,t,n){return t*n[1]+e*n[3]+n[5]}function W(e){if(e.text)return e;if(!e.length)return null;let t=new Path2D;return e.forEach(e=>{t[e[0]](...e.slice(1))}),t}var Y={pathsToShapes:function(e){let t={};for(let n in e){let r=W(e[n]);t[n]=r}return t},pathToBox:function(e){if(!e.length)return null;let t=[],n=[],r=[],a=[];return e.forEach(e=>{if(e[0]in j){let o=j[e[0]](...e.slice(1));t.push(o.xmin),n.push(o.ymin),r.push(o.xmax),a.push(o.ymax)}}),{min:{x:Math.min(...t),y:Math.min(...n)},max:{x:Math.max(...r),y:Math.max(...a)}}},transformBox:function({min:e,max:t},n){let r=Math.min(L(e.x,e.y,n),L(e.x,t.y,n),L(t.x,e.y,n),L(t.x,t.y,n)),a=Math.max(L(e.x,e.y,n),L(e.x,t.y,n),L(t.x,e.y,n),L(t.x,t.y,n));return{min:{x:r,y:Math.min(A(e.x,e.y,n),A(e.x,t.y,n),A(t.x,e.y,n),A(t.x,t.y,n))},max:{x:a,y:Math.max(A(e.x,e.y,n),A(e.x,t.y,n),A(t.x,e.y,n),A(t.x,t.y,n))}}},pathToCanvas:W,pathValidate:function(e){if(!e.length)return"Paths must have at least 1 instruction";let t=[];return e.forEach(e=>{let n=O[e[0]](e.slice(1));n&&t.push(n)}),t},applyTransform:function(e,t){return[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]]}};var D={tracer:function(e=[]){const t={x:[],y:[],checks:{},order:{}};let n=0;function r(e,n){return console.log(e,n,t.order[e],t.order[n]),t.order[e]<t.order[n]?1:t.order[e]>t.order[n]?-1:0}function a(e,t){return e.index<t.index?-1:e.index>t.index?1:0}return{insert:(e,r,o,i)=>{t.checks[o]=i,t.order[o]=n,n+=1,t.x.push({index:Math.floor(e.x),value:o}),t.x.push({index:Math.floor(r.x),value:o}),t.x.sort(a),t.y.push({index:Math.floor(e.y),value:o}),t.y.push({index:Math.floor(r.y),value:o}),t.y.sort(a)},intersectPoint:e=>{let n=new Set,a=Math.floor(e.x),o=Math.floor(e.y);for(let e in t.x){let r=t.x[e];if(!(r.index<=a))break;n.has(r.value)?n.delete(r.value):n.add(r.value)}let i=[...n];n=new Set;for(let e in t.y){let r=t.y[e];if(!(r.index<=o))break;n.has(r.value)?n.delete(r.value):n.add(r.value)}return[...i].filter(e=>n.has(e)).filter(n=>t.checks[n](e.x,e.y)).sort(r)},intersectBox:({min:e,max:n})=>{let a=new Set,o=Math.floor(e.x),i=Math.floor(n.x),s=Math.floor(e.y),l=Math.floor(n.y);for(let e in t.x){let n=t.x[e];if(n.index<=o)a.has(n.value)?a.delete(n.value):a.add(n.value);else{if(!(n.index<=i))break;a.add(n.value)}}let u=[...a];a=new Set;for(let e in t.y){let n=t.y[e];if(n.index<=s)a.has(n.value)?a.delete(n.value):a.add(n.value);else{if(!(n.index<=l))break;a.add(n.value)}}return[...u].filter(e=>a.has(e)).sort(r)}}},boxesIntersect:function(e,t){return!(e.max.x<t.min.x)&&(!(t.max.x<e.min.x)&&(!(e.max.y<t.min.y)&&!(t.max.y<t.max.y)))},boxBox:function(e){return{max:{x:Math.max(...e.map(e=>e.max.x)),y:Math.max(...e.map(e=>e.max.y))},min:{x:Math.min(...e.map(e=>e.min.x)),y:Math.min(...e.map(e=>e.min.y))}}},generateHitChecker:function(e,t,n){return(r,a)=>{e.save(),e.setTransform(...n);const o=e.isPointInPath(t,r,a);return e.restore(),o}}};const X={fillStyle:null,strokeStyle:null,lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"transparent",fill:"nonzero",font:"sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit"};function J(e){let t={...X,...e};return function(e,n){e.lineWidth=t.lineWidth,e.lineCap=t.lineCap,e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset,e.font=t.font,e.textAlign=t.textAlign,e.textBaseline=t.textBaseline,e.direction=t.direction,e.shadowOffsetX=t.shadowOffsetX,e.shadowOffsetY=t.shadowOffsetY,e.shadowBlur=t.shadowBlur,e.shadowColor=t.shadowColor,e.fillStyle=t.fillStyle,e.strokeStyle=t.strokeStyle,n.text?(t.fillStyle&&e.fillText(n.text,n.x,n.y,n.maxWidth),t.strokeStyle&&e.strokeText(n.text,n.x,n.y,n.maxWidth)):(t.fillStyle&&e.fill(n),t.strokeStyle&&e.stroke(n))}}var q={linearGradient:function(e,t,n,r){let a=e.createLinearGradient(t.x,t.y,n.x,n.y);return r.forEach(({loc:e,color:t})=>a.addColorStop(e,t)),a},radialGradient:function(e,t,n,r){let a=e.createRadialGradient(t.x,t.y,t.radius,n.x,n.y,n.radius);return r.forEach(({loc:e,color:t})=>a.addColorStop(e,t)),a},pattern:function(e,t,n){let r=new Image;return r.src(t),e.createPattern(r,n)},palletteToPainter:J,pallettesToPainters:function(e){let t={};for(let n in e){let r=J(e[n]);t[n]=r}return t}};function G({area:e,extents:t,transform:n}){let r=-t.min.x,a=e.width-t.max.x*n[0],o=-t.min.y,i=e.height-t.max.y*n[3];null!==t.min.x&&n[4]<a&&(n[4]=a),null!==t.max.x&&n[4]>r&&(n[4]=r),null!==t.min.y&&n[5]<i&&(n[5]=i),null!==t.max.y&&n[5]>o&&(n[5]=o)}var H={mouse:{zoom:(e,t,n=1.2)=>{let r=t.transform[0]*n**-Math.sign(e.deltaY);r=r>t.extents.max.zoom?t.extents.max.zoom:r;const a=function({extents:e,area:t}){const n=[e.min.zoom];return null!==e.max.x&&null!==e.min.x&&n.push(t.width/(e.max.x-e.min.x)),null!==e.min.y&&null!==e.max.y&&n.push(t.height/(e.max.y-e.min.y)),Math.max(...n)}(t);r=r<a?a:r,function({transform:e},t,n=null,r=null){n=null===n?e[4]+area.width/(2*e[0]):n,r=null===r?e[5]+area.height/(2*e[3]):r,e[4]=n-t*(n-e[4])/e[0],e[5]=r-t*(r-e[5])/e[3],e[0]=t,e[3]=t}(t,r,e.clientX,e.clientY),G(t),e.preventDefault(),e.stopPropagation()},pan:(e,t)=>{let n=e.clientX,r=e.clientY;return e=>{t.transform[4]=t.transform[4]+e.clientX-n,t.transform[5]=t.transform[5]+e.clientY-r,n=e.clientX,r=e.clientY,G(t)}}}};const I={},N={},R={},F={},V={};function K(e,t){F[e]=(e,n,r)=>{n.visible&&(e.save(),e.transform(...n.transform),t(e,n.details,r),e.restore())}}function Q(e,t,n){V[e]={controls:t,init:n}}K("simple",(e,{shape:t,style:n,trace:r},{viewport:a,handles:o,tome:i})=>{const s=e.getTransform(),l=[s.a,s.b,s.c,s.d,s.e,s.f],{box:u,path:m}=i.shape(t),c=Y.transformBox(u,l);D.boxesIntersect(a,c)&&(r&&o.insert(c.min,c.max,r,D.generateHitChecker(e,m,l)),i.style(n).painter(e,m))}),K("nested",(e,{subjects:t},n)=>{t.forEach(t=>{const r=n.tome.subject(t);n.tome.renderer(r.renderer)(e,r,n)})}),K("text",(e,{style:t,text:n,x:r,y:a,maxWidth:o},{tome:i})=>{i.style(t).painter(e,{text:n,x:r,y:a,maxWidth:o})}),Q(null,{},()=>null),Q("default",{mousedown:(e,{geo:t,elem:n})=>{n.set("panning",{mouse:e,geo:t,end:()=>{n.set("default",{geo:t,elem:n})}})},wheel:(e,{geo:t})=>{H.mouse.zoom(e,t.camera)}},e=>e),Q("panning",{mouseup:(e,{end:t})=>{t()},mouseout:(e,{end:t})=>{t()},mousemove:(e,{pan:t})=>{t(e)}},({mouse:e,geo:t,end:n})=>({pan:H.mouse.pan(e,t.camera),end:n}));var U={register:{shape:(e,t)=>{I[e]={instructions:t,path:Y.pathToCanvas(t),box:Y.pathToBox(t)}},style:(e,t)=>{N[e]={styling:t,painter:q.palletteToPainter(t)}},subject:(e,{renderer:t,details:n,visible:r,transform:a})=>{R[e]={renderer:t,details:n,visible:r,transform:a}},renderer:K,mode:Q},shape:e=>I[e],style:e=>N[e],subject:e=>R[e],renderer:e=>F[e],mode:e=>V[e],export:()=>JSON.stringify({subjects:R,shapes:I,styles:N}),import:e=>{imports=JSON.parse(e),I={...I,...imports.shapes},N={...N,...imports.styles},R={...R,...imports.subjects}}};function Z(e){const t={mode:null,listeners:[]};return{set:(n,r)=>{const a=U.mode(n).init(r);t.listeners.forEach(([t,n])=>e.removeEventListener(t,n));let o=[],i=U.mode(n).controls;for(const t in i)o.push([t,n=>i[t](n,a,e)]);o.forEach(([t,n])=>e.addEventListener(t,n)),t.listeners=o,t.mode=n},element:()=>e,mode:()=>t.mode}}function ee(){const e={camera:{transform:[1,0,0,1,0,0],extents:{min:{x:null,y:null,zoom:null},max:{x:null,y:null,zoom:null}},area:{width:800,height:800}},scene:[],tome:U,handles:D.tracer(),render:t=>{t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,e.camera.area.width,e.camera.area.height),t.setTransform(...e.camera.transform);const n=Y.transformBox({min:{x:0,y:0},max:{x:e.camera.area.width,y:e.camera.area.height}},e.camera.transform);e.handles=D.tracer(),e.scene.forEach(r=>{const a=U.subject(r),o=U.renderer(a.renderer);o&&o(t,a,{viewport:n,handles:e.handles,tome:U})})}};return e}function te(t){let n,r,a;return{c(){var o;o="canvas",n=document.createElement(o),this.c=e,l(n,"width",r=t[0].camera.area.width+"px"),l(n,"height",a=t[0].camera.area.height+"px")},m(e,r){i(e,n,r),t[6](n)},p(e,[t]){1&t&&r!==(r=e[0].camera.area.width+"px")&&l(n,"width",r),1&t&&a!==(a=e[0].camera.area.height+"px")&&l(n,"height",a)},i:e,o:e,d(e){e&&s(n),t[6](null)}}}function ne(t,n,r){let a,i,{geo:s=ee()}=n,{mode:l={name:"default",state:{}}}=n,u=function(t,n=e){let r;const a=[];function i(e){if(o(t,e)&&(t=e,r)){const e=!z.length;for(let e=0;e<a.length;e+=1){const n=a[e];n[1](),z.push(n,t)}if(e){for(let e=0;e<z.length;e+=2)z[e][0](z[e+1]);z.length=0}}}return{set:i,update:function(e){i(e(t))},subscribe:function(o,s=e){const l=[o,s];return a.push(l),1===a.length&&(r=n(i)||e),o(t),()=>{const e=a.indexOf(l);-1!==e&&a.splice(e,1),0===a.length&&(r(),r=null)}}}}(l);function m(e){return function t(){i=requestAnimationFrame(t),s.render(e)}(),()=>{cancelAnimationFrame(i)}}return c(()=>{s.render(a.getContext("2d"));const e=Z(a);return u.subscribe(()=>{e.set(l.name,{elem:e,geo:s,...l.state})}),m(a.getContext("2d"))}),t.$set=e=>{"geo"in e&&r(0,s=e.geo),"mode"in e&&r(2,l=e.mode)},t.$$.update=()=>{4&t.$$.dirty&&u.set(l)},[s,a,l,i,u,m,function(e){f[e?"unshift":"push"](()=>{r(1,a=e)})}]}class re extends k{constructor(e){super(),_(this,{target:this.shadowRoot},ne,te,o,{geo:0,mode:2}),e&&(e.target&&i(e.target,this,e.anchor),e.props&&(this.$set(e.props),w()))}static get observedAttributes(){return["geo","mode"]}get geo(){return this.$$.ctx[0]}set geo(e){this.$set({geo:e}),w()}get mode(){return this.$$.ctx[2]}set mode(e){this.$set({mode:e}),w()}}function ae(t){let n,r,a;function o(e){t[2].call(null,e)}function i(e){t[3].call(null,e)}let s={};void 0!==t[0]&&(s.geo=t[0]),void 0!==t[1]&&(s.mode=t[1]);const l=new re({props:s});return f.push(()=>S(l,"geo",o)),f.push(()=>S(l,"mode",i)),{c(){var t;(t=l.$$.fragment)&&t.c(),this.c=e},m(e,t){E(l,e,t),a=!0},p(e,[t]){const a={};!n&&1&t&&(n=!0,a.geo=e[0],v(()=>n=!1)),!r&&2&t&&(r=!0,a.mode=e[1],v(()=>r=!1)),l.$set(a)},i(e){a||(C(l.$$.fragment,e),a=!0)},o(e){!function(e,t,n,r){if(e&&e.o){if(T.has(e))return;T.add(e),(void 0).c.push(()=>{T.delete(e),r&&(n&&e.d(1),r())}),e.o(t)}}(l.$$.fragment,e),a=!1},d(e){B(l,e)}}}function oe(e,t,n){U.register.shape("hexagon",[["moveTo",2.5,43.3],["lineTo",26.25,84.77],["lineTo",73.75,84.77],["lineTo",97.5,43.3],["lineTo",73.75,2.165],["lineTo",26.25,2.165],["closePath"]]),U.register.shape("boundary",[["rect",10,10,780,780]]),U.register.style("black",{fillStyle:"black",lineWidth:3,lineJoin:"round"}),U.register.style("thinBlackLines",{lineWidth:5,strokeStyle:"black",lineJoin:"round"}),U.register.subject("lone hex",{details:{shape:"hexagon",style:"black",trace:"lone hex"},transform:[1,0,0,1,100,100],visible:!0,renderer:"simple"}),U.register.subject("boundaries",{details:{shape:"boundary",style:"thinBlackLines",trace:"boundaries"},transform:[1,0,0,1,0,0],visible:!0,renderer:"simple"}),U.register.subject("base layer",{details:{subjects:["boundaries","lone hex"]},transform:[1,0,0,1,0,0],visible:!0,renderer:"nested"}),U.register.mode("tracing",{mousedown:(e,{geo:t})=>{console.log(t.handles.intersectPoint({x:e.offsetX,y:e.offsetY}))}},e=>e);let r=ee();r.camera.extents={min:{x:0,y:0,zoom:null},max:{x:800,y:800,zoom:5}},r.scene=["base layer"];let a={name:"tracing",state:{}};return[r,a,function(e){r=e,n(0,r)},function(e){a=e,n(1,a)}]}customElements.define("geomancer-scene",re);class ie extends k{constructor(e){super(),_(this,{target:this.shadowRoot},oe,ae,o,{}),e&&e.target&&i(e.target,this,e.anchor)}}return customElements.define("geomancer-example",ie),{Example:ie,Geomancer:re,geomancer:ee,elemental:Z,measure:Y,style:q,tracer:D,tome:U,view:H}}();
//# sourceMappingURL=bundle.js.map
